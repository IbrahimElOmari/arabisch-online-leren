import { supabase } from '@/integrations/supabase/client';
import { z } from 'zod';

// Validation schemas
export const createTicketSchema = z.object({
  subject: z.string().min(5).max(200),
  description: z.string().min(20).max(5000),
  category: z.enum(['technical', 'billing', 'content', 'account', 'other']),
  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
});

export const createMessageSchema = z.object({
  ticket_id: z.string().uuid(),
  message: z.string().min(1).max(2000),
  attachments: z.array(z.string()).optional(),
  is_internal: z.boolean().optional(),
});

export const createKBArticleSchema = z.object({
  title: z.string().min(10).max(200),
  slug: z.string().regex(/^[a-z0-9-]+$/),
  content: z.string().min(50),
  excerpt: z.string().max(300).optional(),
  category: z.string(),
  tags: z.array(z.string()).optional(),
  status: z.enum(['draft', 'published', 'archived']).optional(),
});

// Support Ticket Service
export class SupportService {
  // Create support ticket
  static async createTicket(data: z.infer<typeof createTicketSchema>) {
    const validated = createTicketSchema.parse(data);
    
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    const { data: ticket, error } = await supabase
      .from('support_tickets')
      .insert([{
        user_id: user.data.user.id,
        subject: validated.subject,
        description: validated.description,
        category: validated.category,
        priority: validated.priority || 'medium',
        status: 'open',
        ticket_number: '', // Will be auto-generated by trigger
      }])
      .select()
      .single();

    if (error) throw error;
    return ticket;
  }

  // Get user's tickets
  static async getMyTickets(status?: string) {
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    let query = supabase
      .from('support_tickets')
      .select('*')
      .eq('user_id', user.data.user.id)
      .order('created_at', { ascending: false });

    if (status) {
      query = query.eq('status', status);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data;
  }

  // Get ticket by ID
  static async getTicket(ticketId: string) {
    const { data, error } = await supabase
      .from('support_tickets')
      .select('*')
      .eq('id', ticketId)
      .single();

    if (error) throw error;
    return data;
  }

  // Update ticket status
  static async updateTicketStatus(ticketId: string, status: string) {
    const updates: any = { status };
    
    if (status === 'resolved') {
      updates.resolved_at = new Date().toISOString();
    } else if (status === 'closed') {
      updates.closed_at = new Date().toISOString();
    }

    const { data, error } = await supabase
      .from('support_tickets')
      .update(updates)
      .eq('id', ticketId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  // Assign ticket to support agent
  static async assignTicket(ticketId: string, assignedTo: string) {
    const { data, error } = await supabase
      .from('support_tickets')
      .update({ assigned_to: assignedTo })
      .eq('id', ticketId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  // Add satisfaction rating
  static async rateTicket(ticketId: string, rating: number) {
    if (rating < 1 || rating > 5) {
      throw new Error('Rating must be between 1 and 5');
    }

    const { data, error } = await supabase
      .from('support_tickets')
      .update({ satisfaction_rating: rating })
      .eq('id', ticketId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  // Send message in ticket
  static async sendMessage(data: z.infer<typeof createMessageSchema>) {
    const validated = createMessageSchema.parse(data);
    
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    const { data: message, error } = await supabase
      .from('support_messages')
      .insert({
        ticket_id: validated.ticket_id,
        sender_id: user.data.user.id,
        message: validated.message,
        attachments: validated.attachments || [],
        is_internal: validated.is_internal || false,
      })
      .select()
      .single();

    if (error) throw error;
    return message;
  }

  // Get ticket messages
  static async getTicketMessages(ticketId: string) {
    const { data, error } = await supabase
      .from('support_messages')
      .select('*, sender:profiles(id, full_name)')
      .eq('ticket_id', ticketId)
      .order('created_at', { ascending: true });

    if (error) throw error;
    return data;
  }

  // Get all tickets (admin/support only)
  static async getAllTickets(filters?: {
    status?: string;
    priority?: string;
    category?: string;
    assigned_to?: string;
  }) {
    let query = supabase
      .from('support_tickets')
      .select('*, user:profiles(id, full_name), assigned:profiles(id, full_name)')
      .order('created_at', { ascending: false });

    if (filters?.status) query = query.eq('status', filters.status);
    if (filters?.priority) query = query.eq('priority', filters.priority);
    if (filters?.category) query = query.eq('category', filters.category);
    if (filters?.assigned_to) query = query.eq('assigned_to', filters.assigned_to);

    const { data, error } = await query;
    if (error) throw error;
    return data;
  }

  // Get SLA breach tickets
  static async getSLABreaches() {
    const { data, error } = await supabase
      .from('support_tickets')
      .select('*')
      .lt('sla_deadline', new Date().toISOString())
      .in('status', ['open', 'in_progress', 'waiting_user']);

    if (error) throw error;
    return data;
  }
}

// Knowledge Base Service
export class KnowledgeBaseService {
  // Create article
  static async createArticle(data: z.infer<typeof createKBArticleSchema>) {
    const validated = createKBArticleSchema.parse(data);
    
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    const { data: article, error } = await supabase
      .from('knowledge_base_articles')
      .insert({
        ...validated,
        author_id: user.data.user.id,
        status: validated.status || 'draft',
      })
      .select()
      .single();

    if (error) throw error;
    return article;
  }

  // Get published articles
  static async getPublishedArticles(category?: string) {
    let query = supabase
      .from('knowledge_base_articles')
      .select('*')
      .eq('status', 'published')
      .order('created_at', { ascending: false });

    if (category) {
      query = query.eq('category', category);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data;
  }

  // Search articles
  static async searchArticles(searchQuery: string) {
    const { data, error } = await supabase
      .from('knowledge_base_articles')
      .select('*')
      .eq('status', 'published')
      .textSearch('search_vector', searchQuery);

    if (error) throw error;
    return data;
  }

  // Get article by slug
  static async getArticleBySlug(slug: string) {
    const { data, error } = await supabase
      .from('knowledge_base_articles')
      .select('*, author:profiles(id, full_name)')
      .eq('slug', slug)
      .eq('status', 'published')
      .single();

    if (error) throw error;

    // Increment view count
    await supabase
      .from('knowledge_base_articles')
      .update({ views_count: (data.views_count || 0) + 1 })
      .eq('id', data.id);

    return data;
  }

  // Mark article as helpful
  static async markHelpful(articleId: string, isHelpful: boolean) {
    const field = isHelpful ? 'helpful_count' : 'not_helpful_count';
    
    const { data: current } = await supabase
      .from('knowledge_base_articles')
      .select('helpful_count, not_helpful_count')
      .eq('id', articleId)
      .single();

    const currentValue = isHelpful ? current?.helpful_count : current?.not_helpful_count;
    const newCount = (currentValue || 0) + 1;

    const { error } = await supabase
      .from('knowledge_base_articles')
      .update({ [field]: newCount })
      .eq('id', articleId);

    if (error) throw error;
  }

  // Publish article
  static async publishArticle(articleId: string) {
    const { data, error } = await supabase
      .from('knowledge_base_articles')
      .update({
        status: 'published',
        published_at: new Date().toISOString(),
      })
      .eq('id', articleId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  // Get all articles (admin)
  static async getAllArticles(status?: string) {
    let query = supabase
      .from('knowledge_base_articles')
      .select('*, author:profiles(id, full_name)')
      .order('created_at', { ascending: false });

    if (status) {
      query = query.eq('status', status);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data;
  }
}

// Community Moderation Service
export class ModerationService {
  // Issue warning
  static async issueWarning(userId: string, reason: string, severity: 'minor' | 'moderate' | 'severe') {
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30); // 30 days

    const { data, error } = await supabase
      .from('user_warnings')
      .insert({
        user_id: userId,
        issued_by: user.data.user.id,
        reason,
        severity,
        expires_at: expiresAt.toISOString(),
      })
      .select()
      .single();

    if (error) throw error;

    // Update reputation
    await this.updateReputation(userId, { warnings_count: 1 });

    return data;
  }

  // Ban user
  static async banUser(userId: string, reason: string, banType: 'temporary' | 'permanent', bannedUntil?: string) {
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    const { data, error } = await supabase
      .from('ban_history')
      .insert({
        user_id: userId,
        banned_by: user.data.user.id,
        reason,
        ban_type: banType,
        banned_until: bannedUntil,
        is_active: true,
      })
      .select()
      .single();

    if (error) throw error;

    // Update reputation
    await this.updateReputation(userId, { bans_count: 1 });

    return data;
  }

  // Lift ban
  static async liftBan(banId: string, liftReason: string) {
    const user = await supabase.auth.getUser();
    if (!user.data.user?.id) throw new Error('User not authenticated');

    const { data, error } = await supabase
      .from('ban_history')
      .update({
        is_active: false,
        lifted_by: user.data.user.id,
        lifted_at: new Date().toISOString(),
        lift_reason: liftReason,
      })
      .eq('id', banId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  // Update user reputation
  static async updateReputation(userId: string, updates: {
    reputation_score?: number;
    helpful_posts?: number;
    accepted_answers?: number;
    warnings_count?: number;
    bans_count?: number;
  }) {
    const { data: current } = await supabase
      .from('user_reputation')
      .select('*')
      .eq('user_id', userId)
      .single();

    const newData = {
      user_id: userId,
      reputation_score: (current?.reputation_score || 0) + (updates.reputation_score || 0),
      helpful_posts: (current?.helpful_posts || 0) + (updates.helpful_posts || 0),
      accepted_answers: (current?.accepted_answers || 0) + (updates.accepted_answers || 0),
      warnings_count: (current?.warnings_count || 0) + (updates.warnings_count || 0),
      bans_count: (current?.bans_count || 0) + (updates.bans_count || 0),
      last_updated: new Date().toISOString(),
    };

    const { error } = await supabase
      .from('user_reputation')
      .upsert(newData);

    if (error) throw error;
  }

  // Get user reputation
  static async getUserReputation(userId: string) {
    const { data, error } = await supabase
      .from('user_reputation')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error && error.code !== 'PGRST116') throw error;
    return data || {
      user_id: userId,
      reputation_score: 0,
      helpful_posts: 0,
      accepted_answers: 0,
      warnings_count: 0,
      bans_count: 0,
    };
  }

  // Get user warnings
  static async getUserWarnings(userId: string) {
    const { data, error } = await supabase
      .from('user_warnings')
      .select('*, issued_by_profile:profiles!user_warnings_issued_by_fkey(id, full_name)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
  }

  // Get active bans
  static async getActiveBans(userId?: string) {
    let query = supabase
      .from('ban_history')
      .select('*, user:profiles!ban_history_user_id_fkey(id, full_name), banned_by_profile:profiles!ban_history_banned_by_fkey(id, full_name)')
      .eq('is_active', true)
      .order('created_at', { ascending: false });

    if (userId) {
      query = query.eq('user_id', userId);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data;
  }
}
